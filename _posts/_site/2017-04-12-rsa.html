<p>Криптосистема RSA описана в 1978 году и является, пожалуй, самой популярной на сегодня системой шифрования с открытыми ключами1. Её алгоритмической базой является арифметика над кольцами целых чисел.</p>

<p>Напомним, что если число 𝑛∈𝑁 является составным, то множество {1,2,…𝑛−1}, образованное всеми ненулевыми остатками от деления на 𝑛, группой уже не является, поскольку обязательно найдутся такие 𝑟,𝑠∈{1,…,𝑛−1}, что (𝑟⋅𝑠,𝑚𝑜𝑑 𝑛)=0 (такие числа называются делителями нуля). Множество {0,1,…,𝑛−1} снабженное операциями ⊕𝑛 и ⊗𝑛, является коммутативным кольцом с единицей2 и обозначается далее через 𝑍𝑛. Все перечисленные выше правила работы со сравнениями остаются справедливыми и в кольце. Любой элемент 𝑎∈𝑍𝑛, отличный от нуля и такой, что НОД(𝑎,𝑛)=1, имеет мультипликативно обратный в 𝑍𝑛, то есть такой 𝑎−1, что (𝑎⋅𝑎−1,𝑚𝑜𝑑 𝑛)=1 (поскольку в рассматриваемом случае (𝑎𝜙(𝑛),𝑚𝑜𝑑 𝑝)=1 в силу теоремы Ферма-Эйлера).</p>

<p>В криптосистеме RSA используются два больших простых числа3 𝑝 и 𝑞. Эти числа известны только отправителю (А), который публикует (в открытом заверенном источнике) число 𝑛. Кроме этого у А имеется значение функции Эйлера 𝜙(𝑛) (для данного простейшего случая имеет место 𝜙(𝑛)=(𝑝−1)⋅(𝑞−1)). Используя данные сведения, А строит пару ключей, обозначаемых через 𝑒 (открытый ключ) и 𝑑 (закрытый ключ). Ключ 𝑒 представляет собой число, выбранное случайным образом из множества {1,…,𝜙(𝑛)−1}. Дополнительное требование при этом состоит в том, чтобы НОД(𝑒,𝜙(𝑛))=1. Как известно4, данный факт эквивалентен существованию единственного 𝑑∈{1,…,𝜙(𝑛)−1}, такого, что</p>

<p>𝑒⋅𝑑+𝜙(𝑛)⋅𝑄0=1 (1)</p>

<p>для некоторого целого 𝑄0,𝑄0&lt;0. Уравнение (1) – диофантово уравнение 1-й степени. При известных 𝑒 и 𝑛, таких, что НОД(𝑒,𝜙(𝑛))=1, числа 𝑑 и 𝑄0 находятся эффективно (за полиномиальное от log𝑛 время) при помощи, например, метода цепных дробей. Несложно видеть, что уравнение (1) эквивалентно следующему соотношению:</p>

<p>(𝑒⋅𝑑,𝑚𝑜𝑑 𝜙(𝑛))=1.</p>

<p>Найденное таким образом число 𝑑 является секретным ключом А. Открытый ключ 𝑒 публикуется в заверенном источнике. Допустим, что B хочет отправить А секретное сообщение, представленное числом 𝑥∈{1,…,𝑛−1}. Криптограммой, которую В отправляет в открытый канал, является число 𝑦=(𝑥𝑒,𝑚𝑜𝑑 𝑛). Получив 𝑦, А вычисляет ?=(𝑦𝑑,𝑚𝑜𝑑 𝑛). Очевидно, что (𝑦𝑑,𝑚𝑜𝑑 𝑛)=(𝑥𝑒⋅𝑑,𝑚𝑜𝑑 𝑛)=(𝑥1+𝜙(𝑛)⋅𝑄,𝑚𝑜𝑑 𝑛)=(𝑥⋅(𝑥𝜙(𝑛))𝑄,𝑚𝑜𝑑 𝑛)=𝑥</p>

<p>Здесь 𝑄=−𝑄0 – натуральное число.</p>

<p>Алгоритм RSA можно использовать также и для построения цифровых подписей (именно эта задача была приоритетной при его создании). Протокол построения цифровой подписи с помощью RSA следующий.</p>

<p>Предположим, что А хочет поставить свою уникальную подпись под документом , в роли которого выступает некоторое число из {1,…,𝑛−1} Для этой цели он вместе с 𝑥 отправляет подпись (сигнатуру) 𝑠 – число из {1,…,𝑛−1}, которое строится следующим образом:</p>

<p>𝑠=(𝑥𝑑,𝑚𝑜𝑑 𝑛).</p>

<p>Любой, желающий удостовериться в подписи А, может воспользоваться открытым ключом А и вычислить 𝑥′=(𝑠𝑒,𝑚𝑜𝑑 𝑛), после чего проверить, имеет ли место равенство 𝑥′=𝑥. Если да, то проверяющий может быть уверен, что подпись 𝑠 создана законным обладателем секретного ключа 𝑑, снимающего ключ 𝑒, то есть пользователем А.</p>

<p>На самом деле протокол построения цифровой подписи несколько сложнее, так как подписывать требуется обычно объемные документы, а арифметика в кольце 𝑍𝑛 все-таки довольно медленна. С этой целью подписывают не само большое сообщение 𝑋 а некоторый его «хеш-образ» 𝑥=ℎ(𝑋), 𝑥∈{1,…,𝑛−1}. Несекретная функция ℎ(⋅), называемая хеш-функцией, осуществляет эффективное (за полиномиальное от длины 𝑋 время) сжатие сообщения 𝑋 в некоторое, вообще говоря, бессмысленное сообщение 𝑥, каждый бит которого сложным образом зависит от каждого бита 𝑋. Таким образом, в открытый канал А отправляет пару (𝑋,𝑠). Проверяющему требуется вычислить 𝑥′=(𝑠𝑒,𝑚𝑜𝑑 𝑛), а затем проверить, имеет ли место равенство 𝑥′=ℎ(𝑋). В случае ответа «да» подпись принимается, в противном случае отвергается.</p>
